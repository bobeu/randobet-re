// // SPDX-License-Identifier: MIT

// pragma solidity 0.8.28;

// import { VRFCoordinatorV2Interface } from  "./MockVRFCoordinatorV2.sol";
// import { ICommon } from "./interfaces/ICommon.sol";
// import { VRFConsumerBaseV2Plus } from "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
// import { VRFV2PlusClient } from "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";
// import { Context } from "@openzeppelin/contracts/utils/Context.sol";
// import { IVRFTestSetUp } from "./interfaces/IVRFTestSetUp.sol";
 
// contract VRFTestSetUp is
//     ICommon,
//     Context,
//     IVRFTestSetUp,
//     VRFConsumerBaseV2Plus
// {
//     error CoordinatorAddressIsZero();

//     ///@dev Chainlink request variable: Subscription Id generated by the VRF manager
//     uint256 private subscriptionId;

//     bool public useNativePayment;

//     VRFCoordinatorV2Interface private vrfCoordinator;

//     ///@dev Chainlink varibles
//     ChainLinkData private cData;

//     // Permissions to call VRF i.e this contract
//     mapping(address => bool) public auth;

//     // Mapping of requesters to betType to request Id {Futures}
//     mapping(Consumers => mapping(address => mapping(uint => uint256))) private requestIds;

//     // Mapping of requestIds to randomRequest
//     mapping(uint256 => Consumers) private consumerType;

//     mapping(Consumers => mapping(uint256 => FulfilledRandomCallback)) private requests;

//     modifier isAuthenticated(address target) {
//         require(auth[target], "Not authenticated");
//         _;
//     }

//     constructor(
//         uint256 _subscriptionId,
//         address _vrfCoordinator,
//         bytes32 _keyHash,
//         address[] memory consumers
//     ) VRFConsumerBaseV2Plus(_vrfCoordinator) {
//         require(_vrfCoordinator != address(0), "Coordinator is zero");
//         vrfCoordinator = VRFCoordinatorV2Interface(_vrfCoordinator);
//         subscriptionId = _subscriptionId;
//         cData = ChainLinkData(3, 100000, _keyHash);
//         for (uint8 i = 0; i < consumers.length; i++) {
//             auth[consumers[i]] = true;
//         }
//     }

//     function _toHash(uint arg) internal pure returns (bytes32 _hashed) {
//         _hashed = keccak256(abi.encodePacked(arg));
//     }

//     /// @dev Request random value from the Oracle
//     function requestSpinTools(
//         address user,
//         uint key,
//         Consumers consumer
//     ) external isAuthenticated(_msgSender()) returns (uint256 requestId) {
//         ChainLinkData memory _o = cData;
//         requestId = vrfCoordinator.requestRandomWords(
//             _o.keyHash,
//             subscriptionId,
//             _o.requestConfirmations,
//             _o.callbackGasLimit,
//             1
//         );
//         consumerType[requestId] = consumer;
//         requestIds[consumer][user][key] = requestId;
//         return requestId;
//     }

//     // Oracle delivers request to the requester
//     function fulfilRandomWords(
//         uint requestId,
//         uint256[] memory randomWords
//     ) external returns (bool) {
//         fulfillRandomWords(requestId, randomWords);
//         return true;
//     }

//     function _getRequestId(
//         address user,
//         uint betType,
//         Consumers consumer
//     ) internal view returns (uint requestId) {
//         requestId = requestIds[consumer][user][betType];
//     }

//     function getRequest(
//         address user,
//         uint betType,
//         Consumers consumer
//     )
//         external
//         view
//         isAuthenticated(_msgSender())
//         returns (FulfilledRandomCallback memory req, uint reqId)
//     {
//         reqId = _getRequestId(user, betType, consumer);
//         req = requests[consumer][reqId];
//         return (req, reqId);
//     }

//     function setChainlinkData(
//         uint16 requestConfirmations,
//         uint32 callbackGasLimit,
//         bytes32 keyHash
//     ) public onlyOwner returns (bool) {
//         cData = ChainLinkData(requestConfirmations, callbackGasLimit, keyHash);
//         return true;
//     }

//     function setUseNativePayment(bool value) public onlyOwner returns (bool) {
//         useNativePayment = value;
//         return true;
//     }

//     function setSubcriptionId(uint256 newId) public onlyOwner returns (bool) {
//         subscriptionId = newId;
//         return true;
//     }

//     function approveOrRemoveConsumer(
//         address newOrOldConsumer,
//         bool value
//     ) public onlyOwner returns (bool) {
//         auth[newOrOldConsumer] = value;
//         return true;
//     }

//     /**
//      * @dev Returns request Id to vrf consumer
//      * @param user Target to get request Id for
//      */
//     function getRequestId(
//         address user,
//         uint betType,
//         Consumers consumer
//     ) external view isAuthenticated(_msgSender()) returns (uint256) {
//         return _getRequestId(user, betType, consumer);
//     }

//     // Oracle delivers request to the requester
//     function fulfillRandomWords(
//         uint256 requestId,
//         uint256[] memory randomWords
//     ) internal virtual override {
//         Consumers cs = consumerType[requestId];
//         requests[cs][requestId] = FulfilledRandomCallback( true, _toHash(randomWords[0]));
//     } 
// }







//   // error CoordinatorAddressIsZero();

//   // ///@dev Chainlink request variable: Subscription Id generated by the VRF manager
//   // uint private SUBSCRIPTION_ID;

//   // VRFCoordinatorV2Interface private vrfCoordinator;

//   //   ///@dev Chainlink varibles
//   // ChainLinkData private cData;

//   // constructor(
//   //   uint _subscriptionId,
//   //   address _vrfCoordinator,
//   //   bytes32 _keyHash
//   // ) VRFConsumerBaseV2Plus(_vrfCoordinator)  {
//   //   require(_vrfCoordinator != address(0), "Coordinator is zero");
//   //   vrfCoordinator = VRFCoordinatorV2Interface(_vrfCoordinator);
//   //   SUBSCRIPTION_ID = _subscriptionId;
//   //   cData = ChainLinkData(3, 100000, _keyHash);
//   // } 

//   // /// @dev Request random value from the Oracle
//   // function _requestSpinTools() internal returns(uint requestId) {
//     // ChainLinkData memory _o = cData;
//     //   requestId = vrfCoordinator.requestRandomWords(
//     //     _o.keyHash,
//     //     SUBSCRIPTION_ID,
//     //     _o.requestConfirmations,
//     //     _o.callbackGasLimit,
//     //     1
//     //   );
//   // }

//   //  // Oracle delivers request to the requester
//   // function fulfillRandomWords(uint requestId, uint256[] memory randomWords) internal override {
//   //   _fulfillCallback(requestId, randomWords);
//   // }

//   // function _fulfillCallback(uint requestId, uint256[] memory randomWords) internal virtual;