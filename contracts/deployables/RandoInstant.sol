// // SPDX-License-Identifier: MIT 
// pragma solidity 0.8.28;

// import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
// import { Pausable } from "@openzeppelin/contracts/utils/Pausable.sol";
// import { IERC20 } from "../interfaces/IERC20.sol";
// import { IRandoInstant } from "../interfaces/IRandoInstant.sol";
// import { IiWallet } from "../interfaces/IiWallet.sol";
// import { IWallet } from "./IWallet.sol";
// import { IVRFSetUp } from "../interfaces/IVRFSetUp.sol";
// import { IWalletFactoryInterface } from "../interfaces/IWalletFactoryInterface.sol";


// /**
//   @title RandoInstant:
//     A single sponsored betting that predicts an outcome using a blend of
//     oraclized algorithm from the Chainlink protocols, and an unbiased random selective 
//     mechanism to determine the winner. 
//     This is the second layer of the TreasureHunt that allow anyone to open a bet position
//     by making a deposit into a contract account created seperated for this purpose.
//     Players can then select from the list of sponsored bets on the frontend to play against it.
//     Note: We have adopted this model that depends highly on the Chainlink onchain oracle 
//     service to avoid using the generic random number generation patterns of the blockchain which 
//     are proven to be susceptible to attacks.
//  */
// contract RandoInstant is IRandoInstant, Ownable, Pausable {
//   ///@dev Chainlink request variable: Subscription Id generated by the VRF manager
//   // uint64 private immutable SUBSCRIPTION_ID;

//   ///@dev Minimum amount that can be accepted as a bet
//   uint public minimumDeposit;

//   ///@dev Oracle fee
//   uint public oracleFee;
  
//   ///@dev Address to receive fee
//   address private feeTo;

//   IWalletFactoryInterface public walletFactory;

//   IVRFSetUp public vrfCoordinator;

//   // Mapping of sponsor address to profile
//   mapping( address => Profile ) private profiles;
//   // Profile[] private sponsors;

//   // All positions
//   Position[] private positions;

//   // ERC20 stable token in use
//   IERC20 public usd;

//   /**@dev Request Ids are specific to a hunters. It is generated by the 
//     setter when a request is sent to the oracle.
//    */
//   // mapping(uint => FulfilledRandomCallback) private requests;

//   modifier validatePositionId(uint positionId) { 
//     require(positionId < positions.length, "Invalid positionId");
//     _;
//   }

//   /// #constructor: Sets state variables
//   constructor( IERC20 _usd,  address _feeTo, IWalletFactoryInterface _walletFactory) Ownable(msg.sender) {
//     if(address(_usd) == address(0)) revert AddressIsZero(address(_usd));
//     if(address(_walletFactory) == address(0)) revert AddressIsZero(address(_walletFactory));
//     feeTo = _feeTo;
//     usd = _usd;
//     minimumDeposit = 5e18; // 5 usd
//     oracleFee = 15e14 wei;
//     walletFactory = _walletFactory;
//   }

//   receive() external payable {}

//   function _readWalletBalance(address user, uint expected) internal returns(uint256 balance, address _wallet) {
//     IWalletFactoryInterface.ReturnDataType memory rt = IWalletFactoryInterface(walletFactory).hasWallet(user);
//     _wallet = rt.iWallet;
//     if(!rt.hasWallet) {
//       _wallet = IWalletFactoryInterface(walletFactory).getWallet(user);
//     }
//     balance = IERC20(usd).balanceOf(_wallet);
//     require(balance >= minimumDeposit, "Instant : Balance < minimumDeposit");
//     if(expected > 0) {
//       require(balance >= expected, "Instant: Expected > balance");
//     }
//   }

//   // ///@dev Read approval to spend token from the Hunters' account
//   // function _transferAllowance(address from, address to, uint amount) internal {
//   //   if(!IERC20(usd).transferFrom(from, to, amount)){
//   //     revert DepositSourceContractFailed();
//   //   }
//   // }

//   /**@dev Returns target's dashboard with their position on the sponsors list
//    */
//   function _getProfile(address target) internal view returns(Profile memory profile) {
//     profile = profiles[target];
//   }

//   function _checkAndForwardFee(uint value) internal {
//     (bool success,) = feeTo.call{value: value}('');
//     _validateCondition(value >= oracleFee && success, "FT: failed");
//   }

//   function openNewPosition(uint amount) external payable whenNotPaused returns(bool) {
//     _checkAndForwardFee(msg.value);
//     address caller = _msgSender();
//     (, address wallet) = _readWalletBalance(caller, amount);
//     Profile memory prof = _validateProfile(caller, amount, true, false);
//     uint positionId = positions.length;
//     positions.push(Position(positionId, 0, amount, address(0), caller, Status.OPEN, false));
//     IVRFSetUp(vrfCoordinator).requestSpinTools(caller, positionId, Consumers.INSTANT);
//     profiles[caller] = prof;
//     IiWallet(wallet).eventListener(
//       TransactionData(
//         Events.ONDEPOSITREQUEST,
//         OnDeposit(amount),
//         OnCancel(0),
//         OnWithdraw(0, 0, address(0))
//       )
//     );
//     emit NewPosition(caller, amount, positionId);
//     return true;
//   }

//   function _closePosition(uint positionId) private {
//     positions[positionId].status = Status.CLOSED;
//   }

//   function _validateProfile(address target, uint incominBet, bool isSponsor, bool isSpin) internal view returns(Profile memory prof) {
//     prof = _getProfile(target);
//     require(IWalletFactoryInterface(walletFactory).hasWallet(target).hasWallet, "Instant: No wallet found");
//     if(isSpin) {
//       require(prof.exist, "Not a player");
//     } else {
//       if(!prof.exist) {
//         prof = Profile(
//           true,
//           incominBet,
//           isSponsor? ProofOfInteraction(0, 2) : ProofOfInteraction(1, 0)
//         );
//       }
//     }

//     if(isSponsor) {
//       prof.totalLocked += incominBet;
//       prof.profit.sponsor += 2;
//     } else {
//       prof.profit.player += 1;
//     }
//   } 

//   /**@dev Closes position : only if no player has subscribed
//     @param positionId : Index of futures sponsor wishes to close.
//    */
//   function closePosition(uint positionId) external whenNotPaused validatePositionId(positionId) returns(bool){
//     address caller = _msgSender();
//     Profile memory prof = _getProfile(caller);
//     if(!prof.exist) {
//       revert NotExist();
//     }
//     Position memory pos = positions[positionId];
//     _validateCondition(pos.status == Status.OPEN, "Position closed");
//     if(pos.player != address(0)) {
//       revert CannotClosePosition();
//     }
//     positions[positionId].status = Status.CLOSED;
//     profiles[caller].totalLocked -= pos.totalBet;
//     _closePosition(positionId);
//     IWalletFactoryInterface.ReturnDataType memory rt = IWalletFactoryInterface(walletFactory).hasWallet(pos.creator);
//     IiWallet(rt.iWallet).eventListener(
//       TransactionData(
//         Events.ONCANCELREQUEST,
//         OnDeposit(0),
//         OnCancel(pos.totalBet),
//         OnWithdraw(0, 0, address(0))
//       )
//     );
  
//     emit PositionClosed(caller, pos.totalBet, positionId);
    
//     return true;
//   }

//   function _validateCondition(bool condition, string memory errorMessage) internal pure {
//     require(condition, errorMessage);
//   }

//   function spin(uint positionId) external whenNotPaused validatePositionId(positionId) returns(bool) {
//     address caller = _msgSender();
//     Position memory pos = positions[positionId];
//     (uint256 balance, address _wallet) = _readWalletBalance(caller, pos.totalBet);
//     balance = pos.totalBet;
//     // address iWallet = profiles[pos.creator].iWallet;
//     address iWallet = IWalletFactoryInterface(walletFactory).hasWallet(pos.creator).iWallet;
//     address wallet = IWalletFactoryInterface(walletFactory).hasWallet(caller).iWallet;
//     _validateProfile(caller, balance, false, true);
//     (uint boardFee, uint256 found, uint totalBet) = (0, 0, pos.totalBet * 2);
//     _validateCondition(pos.status == Status.OPEN, "Position closed");
//     (FulfilledRandomCallback memory ffr,) = IVRFSetUp(vrfCoordinator).getRequest(pos.creator, positionId, Consumers.INSTANT);
//     _validateCondition(ffr.fulfilled, "VRF not ready");
//     found = uint256(ffr.value) % totalBet;
//     if(found == totalBet) { // If win equals total pool, take 5%
//       boardFee = (found * 5) / 100;
//       found -= (boardFee + balance);
//       balance = 0;
//     } else if(found < totalBet && (found > pos.totalBet) ){
//       boardFee = ((found - pos.totalBet) * 1) / 100;
//       found -= boardFee;
//       if(found >= balance) {
//         found -= balance;
//         balance = 0;
//       }
//     } else if(found < totalBet && (found < pos.totalBet)) {
//       boardFee = ((pos.totalBet - found) * 1) / 100;
//       found -= boardFee;
//       balance -= found;
//       found = 0;
//     } else {
//       return false;
//     }
    
//     Position memory nPos = Position(pos.index, found, totalBet, caller, pos.creator, Status.CLOSED, false);
//     positions[positionId] = nPos;
//     IiWallet(iWallet).eventListener(
//       TransactionData(
//         Events.ONWITHDRAWREQUEST,
//         OnDeposit(0), 
//         OnCancel(0),
//         OnWithdraw(boardFee, found, wallet)
//       )
//     );
//     if(balance > 0) {
//       IiWallet(_wallet).eventListener(
//         TransactionData(
//           Events.ONWITHDRAWREQUEST,
//           OnDeposit(0), 
//           OnCancel(0),
//           OnWithdraw(0, balance, iWallet)
//         )
//       );
//     }
//     emit Spinned(nPos, positionId);
//     return true;
//   }

//   function getData(address user) public view returns(GetData memory gd){
//     gd.profile = profiles[_msgSender()];
//     gd.iWallet = IWalletFactoryInterface(walletFactory).hasWallet(user).iWallet;
//     gd.positions = positions; 
//     gd.minimumDeposit = minimumDeposit;
//     gd.oracleFee = oracleFee;
//     return gd;
//   }

//   function setMinimumDeosit(uint newDeposit) public onlyOwner {
//     minimumDeposit = newDeposit;
//   }

//   function setOracleFee(uint newFee) public onlyOwner {
//     oracleFee = newFee;
//   }

//     /**@dev Switch between erc20 tokens anytime.
//     This is helpful during development especially live testing
//    */
//   function setToken(IERC20 newUSD) public onlyOwner {
//     require(address(newUSD) != address(0), "NT is 0");
//     usd = newUSD;
//   }

//   function setFeeTo(address newFeeTo) public onlyOwner {
//     require(newFeeTo != address(0), 'Invalid feeTo');
//     feeTo = newFeeTo;
//   }

//   function setIVRFCoordinator(address vrf) public onlyOwner returns(bool) {
//     require(vrf != address(0), "vrf is zero address"); 
//     vrfCoordinator = IVRFSetUp(vrf);
//     return true;
//   }
  
// }



// // function spin(uint positionId) external whenNotPaused validatePositionId(positionId) returns(bool) {
// //     address caller = _msgSender();
// //     Position memory pos = positions[positionId];
// //     (uint256 balance, address caller_wallet) = _readWalletBalance(caller, pos.totalBet);
// //     balance = pos.totalBet;
// //     // address iWallet = profiles[pos.creator].iWallet;
// //     address creator_wallet = IWalletFactoryInterface(walletFactory).hasWallet(pos.creator).iWallet;
// //     // address wallet = IWalletFactoryInterface(walletFactory).hasWallet(caller).iWallet;
// //     _validateProfile(caller, balance, false, true);
// //     (uint boardFee, uint256 found, uint totalBet) = (0, 0, pos.totalBet * 2);
// //     _validateCondition(pos.status == Status.OPEN, "Position closed");
// //     (FulfilledRandomCallback memory ffr,) = IVRFSetUp(vrfCoordinator).getRequest(pos.creator, positionId, Consumers.INSTANT);
// //     _validateCondition(ffr.fulfilled, "VRF not ready");
// //     found = uint256(ffr.value) % totalBet;
// //     if(found == totalBet) { // If win equals total pool, take 5%
// //       boardFee = (found * 5) / 100;
// //       found -= (boardFee + balance);
// //       balance = 0;
// //     } else if(found < totalBet && (found > pos.totalBet) ){
// //       boardFee = ((found - pos.totalBet) * 1) / 100;
// //       found -= boardFee;
// //       if(found >= balance) {
// //         found -= balance;
// //         balance = 0;
// //       }
// //     } else if(found < totalBet && (found < pos.totalBet)) {
// //       boardFee = ((pos.totalBet - found) * 1) / 100;
// //       found -= boardFee;
// //       balance -= found;
// //       found = 0;
// //     } else {
// //       return false;
// //     }
    
// //     Position memory nPos = Position(pos.index, found, totalBet, caller, pos.creator, Status.CLOSED, false);
// //     positions[positionId] = nPos;
// //     IiWallet(creator_wallet).eventListener(
// //       TransactionData(
// //         Events.ONWITHDRAWREQUEST,
// //         OnDeposit(0), 
// //         OnCancel(0),
// //         OnWithdraw(boardFee, found, wallet)
// //       )
// //     );
// //     if(balance > 0) {
// //       IiWallet(caller_wallet).eventListener(
// //         TransactionData(
// //           Events.ONWITHDRAWREQUEST,
// //           OnDeposit(0), 
// //           OnCancel(0),
// //           OnWithdraw(0, balance, iWallet)
// //         )
// //       );
// //     }
// //     emit Spinned(nPos, positionId);
// //     return true;
// //   }