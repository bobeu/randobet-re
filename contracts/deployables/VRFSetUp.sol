// // SPDX-License-Identifier: MIT

// // This contract uses the Chainlink V2.5 version
// pragma solidity 0.8.28;

// // import { IVRFCoordinatorV2Plus } from "@chainlink/contracts/src/v0.8/vrf/dev/interfaces/IVRFCoordinatorV2Plus.sol";
// // import { VRFConsumerBaseV2Plus } from "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
// // import { VRFV2PlusClient } from "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";
// import { ICommon } from "../interfaces/ICommon.sol";
// import { IVRFSetUp } from "../interfaces/IVRFSetUp.sol";
// import { Approved } from "../abstracts/Approved.sol";

// // contract VRFSetUp is ICommon, Approved, IVRFSetUp, VRFConsumerBaseV2Plus {
// abstract contract VRFSetUp is Approved, IVRFSetUp {
//   uint private requestIdCounter;
//   // error CoordinatorAddressIsZero();

//   ///@dev Chainlink request variable: Subscription Id generated by the VRF manager
//   // uint256 private subscriptionId;

//   // bool public useNativePayment;

//   // IVRFCoordinatorV2Plus private vrfCoordinator;

//   ///@dev Chainlink varibles
//   // ChainLinkData private cData;

//   // Permissions to call VRF i.e this contract
//   // mapping (address => bool) public auth;

//   // Mapping of requesters to bet to request Id {Futures}
//   mapping(Consumers => mapping(address => mapping(uint => uint256))) private requestIds;

//   // Mapping of requestIds to randomRequest
//   mapping(uint256 => Consumers) private consumerType;

//   mapping(Consumers => mapping(uint256 => FulfilledRandomCallback[])) private requests;

//   // modifier isAuthenticated(address target) {
//   //   require(auth[target], "Not authenticated");
//   //   _;
//   // }

//   // constructor(address[] memory consumers) VRFConsumerBaseV2Plus(_vrfCoordinator) {
//   //   for(uint8 i = 0; i < consumers.length; i++) {
//   //     _setPermission(consumers[i], true);
//   //   }
//   // }
//   // constructor(
//   //   uint256 _subscriptionId,
//   //   address _vrfCoordinator,
//   //   bytes32 _keyHash,
//   //   address[] memory consumers,
//   //   bool _useNativePayment
//   // ) VRFConsumerBaseV2Plus(_vrfCoordinator)  {
//   //   require(_vrfCoordinator != address(0), "Coordinator is zero");
//   //   useNativePayment = _useNativePayment;
//   //   vrfCoordinator = IVRFCoordinatorV2Plus(_vrfCoordinator);
//   //   subscriptionId = _subscriptionId;
//   //   cData = ChainLinkData(3, 100000, _keyHash);
//   //   for(uint8 i = 0; i < consumers.length; i++) {
//   //     _setPermission(consumers[i], true);
//   //     // auth[consumers[i]] = true;
//   //   }
//   // }

//   function _toHash(uint arg) internal pure returns(bytes32 _hashed) {
//     _hashed = keccak256(abi.encodePacked(arg));
//   }

//   // /// @dev Request random value from the Oracle
//   function requestSpinTools(address user, uint key, Consumers consumer, uint256[] memory randomWords) internal returns(uint256 requestId) {
//     requestId = _generateRequestId();
//     consumerType[requestId] = consumer;
//     requestIds[consumer][user][key] = requestId;
//     _fulfillRandomWords(requestId, user, randomWords);
//   }
//   // function requestSpinTools(address user, uint key, Consumers consumer, uint256[] memory randomWords) external onlyApproved returns(uint256 requestId) {
//   //   requestId = _generateRequestId();
//   //   consumerType[requestId] = consumer;
//   //   requestIds[consumer][user][key] = requestId;
//   //   _fulfillRandomWords(requestId, user, randomWords);
//   //   return requestId;
//   // }

//   // // /// @dev Request random value from the Oracle
//   // function requestSpinTools(address user, uint key, Consumers consumer) external onlyApproved returns(uint256 requestId) {
//   //   ChainLinkData memory _o = cData;
//   //   requestId = vrfCoordinator.requestRandomWords(
//   //   VRFV2PlusClient.RandomWordsRequest({
//   //       keyHash: _o.keyHash,
//   //       subId: subscriptionId,
//   //       requestConfirmations: _o.requestConfirmations,
//   //       callbackGasLimit: _o.callbackGasLimit,
//   //       numWords: 1,
//   //       extraArgs: VRFV2PlusClient._argsToBytes(
//   //           VRFV2PlusClient.ExtraArgsV1({nativePayment: useNativePayment})
//   //       )
//   //     })
//   //   );
//   //   consumerType[requestId] = consumer;
//   //   requestIds[consumer][user][key] = requestId;
//   //   return requestId;
//   // }

//   // /**
//   //  * @dev Returns request Id to vrf consumer
//   //  * @param user Target to get request Id for
//   //  */
//   // function getRequestId(
//   //     address user,
//   //     uint bet,
//   //     Consumers consumer
//   // ) external view returns(uint256) {
//   //     return _getRequestId(user, bet, consumer);
//   // }

//   function _fulfillRandomWords(uint256 requestId, address  uint256[] memory randomPults) internal {
//     Consumers cs = consumerType[requestId];
//     for(uint i = 0; i < randomPults.length; i++){
//       requests[cs][requestId].push(FulfilledRandomCallback(true, _toHash(randomPults[i])));
//     }
//   }

//   // // Oracle delivers request to the requester
//   // function fulfillRandomWords(uint256 requestId, address  uint256[] memory randomWords) internal override {
//   //   Consumers cs = consumerType[requestId];
//   //   requests[cs][requestId] = FulfilledRandomCallback( true, _toHash(randomWords[0]));
//   // }

//   function _getRequestId(address user, uint bet, Consumers consumer) internal view returns(uint requestId) {
//     requestId = requestIds[consumer][user][bet];
//   }

//   function _generateRequestId(address user, uint bet, Consumers consumer) internal view returns(uint requestId) {
//     requestIdCounter ++;
//     requestId = requestIdCounter;
//   }

//   function _getRequest(address user, uint bet, Consumers consumer) internal view onlyApproved returns(FulfilledRandomCallback[] memory reqs, uint reqId){
//     reqId = _getRequestId(user, bet, consumer);
//     reqs = requests[consumer][reqId];
//   }
//   // function getRequest(address user, uint bet, Consumers consumer) external view onlyApproved returns(FulfilledRandomCallback[] memory reqs, uint reqId){
//   //   reqId = _getRequestId(user, bet, consumer);
//   //   reqs = requests[consumer][reqId];
//   //   return (req, reqId);
//   // }

//   // /**
//   //  * @dev Returns request Id to vrf consumer
//   //  * @param user Target to get request Id for 
//   //  */
//   // function getRequestId(address user, uint bet, Consumers consumer) external view onlyApproved returns(uint256){
//   //   return _getRequestId(user, bet, consumer);
//   // }

//   // function setChainlinkData(
//   //   uint16 requestConfirmations,
//   //   uint32 callbackGasLimit,
//   //   bytes32 keyHash
//   // ) public onlyOwner returns(bool) {
//   //   cData = ChainLinkData(requestConfirmations, callbackGasLimit, keyHash);
//   //   return true;
//   // }

//   // function setUseNativePayment(bool value) public onlyApproved returns(bool) {
//   //   useNativePayment = value;
//   //   return true;
//   // }

//   // function setSubcriptionId(uint256 newId) public onlyApproved returns(bool) {
//   //   subscriptionId = newId;
//   //   return true;
//   // }

//   function approveOrRemoveConsumer(address newOrOldConsumer, bool value) public onlyOwner returns(bool) {
//     _setPermission(newOrOldConsumer, value);
//     return true;
//   }
// }