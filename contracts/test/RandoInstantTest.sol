// // SPDX-License-Identifier: MIT 

// pragma solidity 0.8.28
// ;
// import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
// import { Pausable } from "@openzeppelin/contracts/utils/Pausable.sol";
// import { IERC20 } from "../interfaces/IERC20.sol";
// import { IRandoInstantTest } from "../interfaces/IRandoInstantTest.sol";
// import { IRandoInstant } from "../interfaces/IRandoInstant.sol";
// import { IWallet } from "./IWallet.sol";
// import { IiWallet } from "../interfaces/IiWallet.sol";
// import { IVRFTestSetUp } from "../interfaces/IVRFTestSetUp.sol";
// import { IWalletFactoryInterface } from "../interfaces/IWalletFactoryInterface.sol";


// /**
//   @title RandoInstantTest:
//     A one-by-one sponsored lottery model that tries to predict the future using a blend of
//     oraclized algorithm from the Chainlink protocols, and an unbiased random selective 
//     mechanism to determine the winner. 
//     This is the second layer of the TreasureHunt that allow sponsors quickly set up a 
//     lottery game by making a deposit into a special contract account.
//     Players can make arbitrary selection from the list of sponsored lotteries to bet on the
//     futures.
//     Note: We have adopted this model that depends highly on the Chainlink onchain oracle 
//     service to avoid using the generic random generation patterns of the blockchain which 
//     are proven to be susceptible to attacks.
//  */ 
// contract RandoInstantTest is IRandoInstantTest,  Ownable, Pausable {
//    ///@dev Chainlink request variable: Subscription Id generated by the VRF manager
//   // uint64 private immutable SUBSCRIPTION_ID;

//   ///@dev Minimum amount that can be accepted as a bet
//   uint public minimumDeposit;

//   ///@dev Oracle fee
//   uint public oracleFee;
  
//   ///@dev Address to receive fee
//   address private feeTo;

//   IVRFTestSetUp private vrfCoordinator;

//   IWalletFactoryInterface public walletFactory;

//   // Mapping of sponsor address to profile
//   mapping( address => Profile ) private profiles;
//   // Profile[] private sponsors;

//   // All positions
//   Position[] private positions;

//   // ERC20 stable token in use
//   IERC20 public usd;

//   /**@dev Request Ids are specific to a hunters. It is generated by the 
//     setter when a request is sent to the oracle.
//    */
//   // mapping(uint => FulfilledRandomCallback) private requests;

//   modifier validatePositionId(uint positionId) { 
//     require(positionId < positions.length, "Invalid positionId");
//     _;
//   }

//   /// #constructor: Sets state variables
//   constructor( IERC20 _usd,  address _feeTo ) Ownable(msg.sender) {
//     if(address(_usd) == address(0)) revert AddressIsZero(address(_usd));
//     feeTo = _feeTo;
//     usd = _usd;
//     minimumDeposit = 5e18; // 5 usd
//     oracleFee = 15e14 wei;
//   }

//   receive() external payable {}

//   // function _fulfillCallback(uint requestId, uint256[] memory randomWords) internal override {
//   //   requests[requestId] = FulfilledRandomCallback(true, keccak256(abi.encodePacked(randomWords[0])));
//   // }

//   function _readAllowance(address from, uint expected) internal view returns(uint256 allowance) {
//     allowance = IERC20(usd).allowance(from, address(this));
//     require(allowance >= minimumDeposit && (expected > 0? allowance >= expected : true), "Instant Allowance too low");
//   }
  
//   function _readWalletBalance(address user, uint expected) internal returns(uint256 balance, address _wallet) {
//     IWalletFactoryInterface.ReturnDataType memory rt = IWalletFactoryInterface(walletFactory).hasWallet(user);
//     _wallet = rt.iWallet;
//     if(!rt.hasWallet) {
//       _wallet = IWalletFactoryInterface(walletFactory).getWallet(user);
//     }
//     balance = IERC20(usd).balanceOf(_wallet);
//     require(balance >= minimumDeposit, "Instant : Balance < minimumDeposit");
//     if(expected > 0) {
//       require(balance >= expected, "Instant: Expected > balance");
//     }
//   }

//   ///@dev Read approval to spend token from the Hunters' account
//   function _transferAllowance(address from, address to, uint amount) internal {
//     if(!IERC20(usd).transferFrom(from, to, amount)){
//       revert DepositSourceContractFailed();
//     }
//   }

//   /**@dev Returns target's dashboard with their position on the sponsors list
//    */
//   function _getProfile(address target) internal view returns(Profile memory profile) {
//     profile = profiles[target];
//   }

//   function _checkAndForwardFee(uint value) internal {
//     (bool done,) = feeTo.call{value: value}('');
//     _validateCondition(value >= oracleFee && done, "FT: failed");
//   }

//    function openNewPosition(uint amount) external payable whenNotPaused returns(bool) {
//     _checkAndForwardFee(msg.value);
//     address caller = _msgSender();
//     (uint balance, address wallet) = _readWalletBalance(caller, amount);
//     Profile memory prof = _validateProfile(caller, amount, true, false);
//     uint positionId = positions.length;
//     positions.push(Position(positionId, 0, amount, address(0), caller, Status.OPEN, false));
//     IVRFTestSetUp(vrfCoordinator).requestSpinTools(caller, positionId, Consumers.INSTANT);
//     profiles[caller] = prof;
//     IiWallet(wallet).eventListener(
//       TransactionData(
//         Events.ONDEPOSITREQUEST,
//         OnDeposit(balance),
//         OnCancel(0),
//         OnWithdraw(0, 0, address(0))
//       )
//     );
//     emit NewPosition(caller, balance, positionId);
//     return true;
//   }

//   function _closePosition(uint positionId) private {
//     positions[positionId].status = Status.CLOSED;
//   }

//   function _validateProfile(address target, uint incominBet, bool isSponsor, bool isSpin) internal view returns(Profile memory prof) {
//     prof = _getProfile(target);
//     require(IWalletFactoryInterface(walletFactory).hasWallet(target).hasWallet, "Instant: No wallet found");
//     if(isSpin) {
//       require(prof.exist, "Not a player");
//     } else {
//       if(!prof.exist) {
//         prof = Profile(
//           true,
//           incominBet,
//           isSponsor? ProofOfInteraction(0, 2) : ProofOfInteraction(1, 0)
//         );
//       }
//     }
//   }
  

//   /**@dev Closes position : only if no player has subscribed
//     @param positionId : Index of futures sponsor wishes to close.
//    */
//   function closePosition(uint positionId) external whenNotPaused validatePositionId(positionId) returns(bool){
//     address caller = _msgSender();
//     Profile memory prof = _getProfile(caller);
//     if(!prof.exist) {
//       revert NotExist();
//     }
//     Position memory pos = positions[positionId];
//     _validateCondition(pos.status == Status.OPEN, "Position closed");
//     if(pos.player != address(0)) {
//       revert CannotClosePosition();
//     }
//     positions[positionId].status = Status.CLOSED;
//     profiles[caller].totalLocked -= pos.totalBet;
//     _closePosition(positionId);
//     IWalletFactoryInterface.ReturnDataType memory rt = IWalletFactoryInterface(walletFactory).hasWallet(pos.creator);
//     IiWallet(rt.iWallet).eventListener(
//       TransactionData(
//         Events.ONCANCELREQUEST,
//         OnDeposit(0),
//         OnCancel(pos.totalBet),
//         OnWithdraw(0, 0, address(0))
//       )
//     );
  
//     emit PositionClosed(caller, pos.totalBet, positionId);
    
//     return true;
//   }

//   function _validateCondition(bool condition, string memory errorMessage) internal pure {
//     require(condition, errorMessage);
//   }

//   function spin(uint positionId) external whenNotPaused validatePositionId(positionId) returns(bool) {
//     address caller = _msgSender();
//     Position memory pos = positions[positionId];
//     (uint256 balance, address _wallet) = _readWalletBalance(caller, pos.totalBet);
//     balance = pos.totalBet;
//     // address iWallet = profiles[pos.creator].iWallet;
//     address iWallet = IWalletFactoryInterface(walletFactory).hasWallet(pos.creator).iWallet;
//     address wallet = IWalletFactoryInterface(walletFactory).hasWallet(caller).iWallet;
//     _validateProfile(caller, balance, false, true);
//     (uint boardFee, uint256 found, uint totalBet) = (0, 0, pos.totalBet * 2);
//     _validateCondition(pos.status == Status.OPEN, "Position closed");
//     (FulfilledRandomCallback memory ffr,) = IVRFTestSetUp(vrfCoordinator).getRequest(pos.creator, positionId, Consumers.INSTANT);
//     _validateCondition(ffr.fulfilled, "VRF not ready"); 
//     found = uint256(ffr.value) % totalBet;
//     if(found == totalBet) { // If win equals total pool, take 5%
//       boardFee = (found * 5) / 100;
//       found -= (boardFee + balance);
//       balance = 0;
//     } else if(found < totalBet && (found > pos.totalBet) ){
//       boardFee = ((found - pos.totalBet) * 1) / 100;
//       found -= boardFee;
//       if(found >= balance) {
//         found -= balance;
//         balance = 0;
//       }
//     } else if(found < totalBet && (found < pos.totalBet)) {
//       boardFee = ((pos.totalBet - found) * 1) / 100;
//       found -= boardFee;
//       balance -= found;
//       found = 0;
//     } else {
//       return false;
//     }
    
//     Position memory nPos = Position(pos.index, found, totalBet, caller, pos.creator, Status.CLOSED, false);
//     positions[positionId] = nPos;
//     IiWallet(iWallet).eventListener(
//       TransactionData(
//         Events.ONWITHDRAWREQUEST,
//         OnDeposit(0), 
//         OnCancel(0),
//         OnWithdraw(boardFee, found, wallet)
//       )
//     );
//     if(balance > 0) {
//       IiWallet(_wallet).eventListener(
//         TransactionData(
//           Events.ONWITHDRAWREQUEST,
//           OnDeposit(0), 
//           OnCancel(0),
//           OnWithdraw(0, balance, iWallet)
//         )
//       );
//     }
//     emit Spinned(nPos, positionId);
//     return true;
//   }

//   function getData(address user) public view returns(GetData memory gd){
//     gd.profile = profiles[_msgSender()];
//     gd.iWallet = IWalletFactoryInterface(walletFactory).hasWallet(user).iWallet;
//     gd.positions = positions; 
//     gd.minimumDeposit = minimumDeposit;
//     gd.oracleFee = oracleFee;
//     return gd;
//   }

//   function setMinimumDeosit(uint newDeposit) public onlyOwner {
//     minimumDeposit = newDeposit;
//   }

//   function setOracleFee(uint newFee) public onlyOwner {
//     oracleFee = newFee;
//   }

//     /**@dev Switch between erc20 tokens anytime.
//     This is helpful during development especially live testing
//    */
//   function setToken(IERC20 newUSD) public onlyOwner {
//     require(address(newUSD) != address(0), "NT is 0");
//     usd = newUSD;
//   }

//   function setFeeTo(address newFeeTo) public onlyOwner {
//     require(newFeeTo != address(0), 'Invalid feeTo');
//     feeTo = newFeeTo;
//   }

//   function setIVRFCoordinator(address vrf) public onlyOwner returns(bool) {
//     require(vrf != address(0), "vrf is zero address"); 
//     vrfCoordinator = IVRFTestSetUp(vrf);
//     return true;
//   }
// }
